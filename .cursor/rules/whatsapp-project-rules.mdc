---
description: Guidelines for updating the FastAPI backend to ensure consistency with the project’s established structure and standards
alwaysApply: false
---
*This document should be updated whenever new patterns emerge or existing ones are refined. All team members should follow these guidelines to maintain code quality and project consistency.*

WhatsApp Project Rules & Best Practices

Project Structure & Organization

Service Layer Architecture
- All business logic MUST be encapsulated in service classes under `app/services/`
- Services should inherit from `BaseService` to ensure proper database connection handling
- Each service should have a single responsibility (e.g., `ConversationService`, `MessageService`, `AuthService`)
- Keep service files under 300 lines - when a service grows beyond this, create subdirectories and split into focused modules
- Create global service instances at the end of each service file for singleton usage across the application

Database Connection Pattern
- ALWAYS use `db = await self._get_db()` at the start of database-interacting methods
- NEVER use `self.db` directly in service methods - this prevents `NoneType` errors
- Set `self.db` in `__init__` as a safety net if database is already connected
- All database operations must go through the service layer - never access database directly from routes

Service Import & Usage Pattern
- Import global service instances from `app.services` (e.g., `from app.services import conversation_service`)
- NEVER create local service instances in routes - use the global singletons
- Update `app/services/__init__.py` to export all global service instances
- Remove `@staticmethod` decorators from service methods that need database access

API Routes & Endpoints

Route Organization
- ONE endpoint per file - this is MANDATORY
- Group routes by feature under `app/api/routes/<feature>/`
- Use descriptive file names that match the endpoint functionality
- Keep routes clean and focused - delegate business logic to services

Route Structure Pattern
```python
@router.post("/endpoint", response_model=ResponseModel)
async def endpoint_name(
    request_data: RequestModel, 
    current_user: User = Depends(require_permissions(["permission:action"]))
):
    """
    Clear docstring describing the endpoint functionality.
    """
    try:
        # 1. Request validation
        # 2. Business logic via services
        # 3. Database operations via services
        # 4. Audit logging
        # 5. Response
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        raise handle_database_error(e, "endpoint_name", "entity")
```

Service Usage in Routes
- Import services from `app.services`: `from app.services import conversation_service, message_service`
- Use service methods directly: `await conversation_service.create_conversation(...)`
- Never instantiate services locally: Remove `service = ServiceClass()` from routes
- Use specific audit methods: `await audit_service.log_message_sent(...)` instead of generic `log_event`

Schema & Validation

Schema Organization
- Request schemas in `app/schemas/<feature>/<entity>_in.py`
- Response schemas in `app/schemas/<feature>/<entity>_out.py`
- Or combine in single file: `app/schemas/<feature>/<entity>.py`
- Import specific classes: `from app.schemas.whatsapp.chat.conversation import ConversationCreate, ConversationResponse`
- Avoid `import *` to prevent naming conflicts

Schema Validation
- Validate ALL incoming data with Pydantic request schemas
- Enforce strict types and validation rules
- Use descriptive field names that match API expectations
- Document all possible responses in FastAPI docstrings

IMPORTANT: Schema vs Model Usage
- NEVER import response schemas from `app.db.models` - models are for MongoDB collection or others DBs mapping only
- ALWAYS import schemas from `app.schemas` for request/response validation
- Models (`app/db/models/`) are for database structure reflection
- Schemas (`app/schemas/`) are for API input/output validation

Error Handling & Logging

Error Handling Pattern
- Wrap all endpoint code in try/except blocks
- Log full error details via `core/logger.py`
- Return sanitized error responses to clients
- Use centralized error codes from `config/error_codes.py`
- Handle specific exceptions first, then generic `Exception`

Logging Standards
- Use structured logging with correlation IDs
- Include relevant context (user_id, conversation_id, etc.)
- Log at appropriate levels (INFO, WARNING, ERROR)
- Use descriptive log messages with emojis for quick identification

Database Models & Collections

Model Organization
- Place models in appropriate subfolders under `app/db/models/`
- Create new subfolders if needed for feature-specific models
- Use Pydantic models for all MongoDB collections
- Update indexes in `app/db/client.py` when adding new fields

Database Operations
- Use Motor async operations for all database interactions
- Handle ObjectId conversions properly
- Validate data before database operations
- Use proper error handling for database failures

WhatsApp Integration

WhatsApp Service Usage
- Use correct method signatures: `send_text_message(to_number=..., text=...)`
- Format phone numbers using the service's `_format_phone_number` method
- Handle WhatsApp API errors gracefully
- Log all WhatsApp API interactions for debugging

Message Flow
- Validate conversation exists before sending messages
- Create messages in database after successful WhatsApp send
- Update conversation metadata (message count, last message, etc.)
- Log all message activities for audit trail

Authentication & Permissions

Permission System
- Use `require_permissions(["permission:action"])` for endpoint protection
- Check user permissions before sensitive operations
- Support super admin bypass for administrative functions
- Log permission checks for security auditing

User Context
- Always get current user from FastAPI dependencies
- Include user context in audit logs
- Validate user permissions for conversation access
- Handle user session management properly

Audit & Monitoring

Audit Logging
- Log all significant activities (message sends, conversation changes, etc.)
- Include correlation IDs for request tracing
- Store audit logs in dedicated collection
- Use specific audit methods for different event types

**MANDATORY AUDIT LOGGING RULE**
- **ALL endpoints that perform user actions (create, update, delete, assign, etc.) MUST include audit logging**
- Use `audit_service.user_management.log_*()` methods for user management actions
- Use `audit_service.log_*()` methods for conversation/message actions
- Always include correlation ID: `correlation_id = get_correlation_id()`
- Always log actor information: `actor_id`, `actor_name`
- Track changes for update operations (before/after values)
- Place audit logging after successful operation but before response
- Pattern:
```python
# ===== AUDIT LOGGING =====
correlation_id = get_correlation_id()
await audit_service.user_management.log_action_name(
    actor_id=str(current_user.id),
    actor_name=current_user.name or current_user.email,
    # ... other relevant parameters
    correlation_id=correlation_id
)
```

Performance Monitoring
- Log request/response times for performance tracking
- Monitor database connection health
- Track service method execution times
- Alert on critical errors

Code Quality & Maintenance

Code Organization
- Follow single responsibility principle for all classes and functions
- Keep functions small and focused (under 50 lines when possible)
- Use descriptive variable and function names
- Add docstrings for complex functions and classes

Import Management
- Organize imports (standard library, third-party, local)
- Use specific imports instead of wildcard imports
- Avoid circular imports by careful module organization
- Update imports when refactoring service structure

Testing Considerations
- Write unit tests for all service methods
- Mock external dependencies (WhatsApp API, database)
- Test error scenarios and edge cases
- Maintain test coverage above 80%

Deployment & Configuration

Environment Management
- Use Pydantic Settings for all configuration
- Load from environment variables via `.env` files
- Validate configuration at startup
- Provide sensible defaults for development

Docker & Containerization
- Use multi-stage Dockerfile for production builds
- Run as non-root user for security
- Cache dependencies for faster builds
- Test Docker builds after dependency changes

Migration & Refactoring

When Refactoring Services
- Update all import statements across the codebase
- Ensure global instances are properly exported
- Test all affected endpoints after changes
- Update documentation to reflect new structure

Database Schema Changes
- Update indexes when adding new fields
- Handle data migrations carefully
- Test with existing data before deployment
- Backup data before major schema changes

Common Patterns to Follow

Service Method Pattern
```python
async def method_name(self, param1: str, param2: int) -> Optional[Dict]:
    """
    Clear description of what this method does.
    """
    db = await self._get_db()
    
    try:
        # Database operations using db.collection if using mongo
        result = await db.collection.find_one({"field": param1})
        
        # Business logic
        if result:
            # Process result
            return processed_result
        else:
            return None
            
    except Exception as e:
        logger.error(f"Error in method_name: {str(e)}")
        raise
```

Route Pattern
```python
@router.post("/endpoint", response_model=ResponseModel)
async def endpoint_name(
    request_data: RequestModel, 
    current_user: User = Depends(require_permissions(["permission:action"]))
):
    """
    Endpoint description with examples.
    """
    try:
        # 1. Validation
        # 2. Service calls
        result = await service.method_name(request_data.field)
        
        # 3. Audit logging
        await audit_service.log_event(...)
        
        # 4. Response
        return ResponseModel(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        raise handle_database_error(e, "endpoint_name", "entity")
```

Anti-Patterns to Avoid

❌ Don't Do This
- Direct database access in routes like: `await database.db.collection.find_one(...)`
- Local service instantiation: `service = ServiceClass()` in routes
- Using `self.db` directly: `self.db.collection.find_one(...)` without `_get_db()`
- Generic error handling: Catching all exceptions without specific handling
- Large monolithic files: Files with multiple responsibilities or >300 lines
- Circular imports: Importing modules that import each other
- Hard-coded values: Using magic numbers or strings instead of configuration
- Multiple endpoints per file: Always use ONE endpoint per file
- Importing schemas from models: Use `app.schemas` for API validation, `app.db.models` for database mapping only

✅ Do This Instead
- Use service methods like: `await conversation_service.get_conversation(id)`
- Import global instances: `from app.services import conversation_service`
- Use `_get_db()` pattern: `db = await self._get_db()` then `db.collection`
- Specific error handling: Catch specific exceptions, then generic
- Small focused files: One responsibility per file, split when needed
- Clean import structure: Organize imports to avoid circular dependencies
- Configuration-driven: Use environment variables for all configurable values
- One endpoint per file: Each route file contains exactly ONE endpoint
- Proper schema imports: Import request/response schemas from `app.schemas`, models from `app.db.models`

File Naming Conventions Examples

Services
- `conversation_service.py` - Main conversation operations
- `message_service.py` - Message handling
- `auth_service.py` - Authentication and authorization
- `audit_service.py` - Audit logging
- `whatsapp_service.py` - WhatsApp API integration

Routes
- `create_conversation.py` - Single endpoint for creating conversations
- `send_message.py` - Single endpoint for sending messages
- `get_conversation.py` - Single endpoint for retrieving conversations
- `update_conversation.py` - Single endpoint for updating conversations

Schemas
- `conversation.py` - All conversation-related schemas
- `message.py` - All message-related schemas
- `user.py` - All user-related schemas
- `audit.py` - All audit-related schemas

Testing Guidelines

Service Testing
- Mock database connections for unit tests
- Test all service methods with various inputs
- Verify error handling for edge cases
- Test async methods properly

Integration Testing
- Test complete request flows from route to database
- Mock external APIs (WhatsApp, etc.)
- Test authentication and permissions
- Verify audit logging occurs correctly

Documentation Standards

Code Documentation
- Add docstrings to all public methods
- Document parameters and return types
- Include usage examples for complex methods
- Update README.md when adding new features

API Documentation
- Use FastAPI docstrings for automatic OpenAPI generation
- Document all request/response models
- Include error responses in documentation
- Provide usage examples for each endpoint

Performance Guidelines

Database Performance
- Use proper indexes for frequently queried fields
- Limit query results with pagination
- Use projection to select only needed fields
- Monitor query performance and optimize slow queries

API Performance
- Use async/await for all I/O operations
- Implement caching for frequently accessed data
- Optimize response sizes by selecting only needed fields
- Monitor response times and optimize slow endpoints

Security Best Practices

Input Validation
- Validate all inputs with Pydantic schemas
- Sanitize user inputs to prevent injection attacks
- Use parameterized queries for database operations
- Validate file uploads and media content

Authentication & Authorization
- Use JWT tokens for authentication
- Implement proper session management
- Check permissions before sensitive operations
- Log security events for monitoring

Data Protection
- Encrypt sensitive data at rest and in transit
- Use HTTPS for all API communications
- Implement rate limiting to prevent abuse
- Regular security audits of the codebase

Monitoring & Observability

Logging Strategy
- Structured logging with consistent format
- Correlation IDs for request tracing
- Log levels appropriate for different environments
- Centralized log collection for analysis

Metrics & Monitoring
- Track key metrics (response times, error rates)
- Monitor database performance and connection health
- Alert on critical errors and performance issues
- Use health checks for service availability

Deployment Checklist

Before Deployment
- [ ] All tests pass (unit and integration)
- [ ] Docker builds successfully with new changes
- [ ] Environment variables are properly configured
- [ ] Database migrations are tested
- [ ] API documentation is updated
- [ ] Performance impact is assessed

After Deployment
- [ ] Monitor application logs for errors
- [ ] Verify all endpoints are working correctly
- [ ] Check database connections and performance
- [ ] Monitor external API integrations
- [ ] Update deployment documentation if needed

Emergency Procedures

Rollback Strategy
- Keep previous versions ready for quick rollback
- Database backups before major deployments
- Feature flags for gradual rollouts
- Monitoring alerts for immediate issue detection

Incident Response
- Log all incidents with full context
- Document root causes and solutions
- Update runbooks based on lessons learned
- Communicate status to stakeholders promptly

Critical Rules Summary

1. ONE endpoint per file - This is MANDATORY
2. Use services for business logic - Never put database operations directly in routes
3. Import schemas from `app.schemas` - Never import response schemas from `app.db.models`
4. Use global service instances - Never create local service instances in routes
5. Follow the `_get_db()` pattern - Always use `db = await self._get_db()` in service methods
6. Keep files under 300 lines - Split into subdirectories when services grow
7. Proper error handling - Catch specific exceptions, then generic ones
8. Clean imports - Organize imports and avoid circular dependencies

Update runbooks based on lessons learned
Communicate status to stakeholders promptly








