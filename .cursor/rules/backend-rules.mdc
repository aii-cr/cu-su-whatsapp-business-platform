---
description: Guidelines for updating the FastAPI backend to ensure consistency with the projectâ€™s established structure and standards
alwaysApply: false
---
[Configuration Management]
 - Centralize all mutable settings (tokens, IDs, URIs, timeouts, feature flags) in `core/config.py` via Pydantic `BaseSettings`, loading from `.env`.  
 - Avoid hard-coding any values; expose every changeable parameter as an environment variable.

[Commenting]
 - Never address the developer in comments; only include concise explanations at complex or non-obvious parts (function/class docstrings).

[Code Structure & Organization]
 - Organize code by feature under `app/` (`routes/`, `services/`, `db/models/`, `schemas/`, `utils/`).  
 - Encapsulate business logic in service classes under `app/services/` (e.g., `ConversationService`, `NotificationService`).  
 - Place reusable helpers in `app/utils/<feature>/`; group routes by feature in `app/routes/<feature>/`.  

[Validation & Schemas]
 - Validate all incoming data with Pydantic request schemas under `db/schemas/<feature>_in.py`; enforce strict types.  
 - Define output schemas in `db/schemas/<feature>_out.py` and bind them to endpoints so `/docs` remains accurate.  
 - Model every MongoDB collection with a Pydantic model in `db/models/<feature>.py` for clear mapping of DB records.

[Error Handling & Logging]
 - Wrap endpoint code in `try/except`; on exception, log full details via `core/logger.py` and return a sanitized error response.  
 - Log all endpoint hits, request processing steps, and errors using `core/logger.py` with structured logging including correlation IDs, request metadata, processing stages, and detailed error context for complete request lifecycle tracking.
 - Centralize error codes and user-friendly messages in `config/error_code.py`; reference these codes in all HTTPExceptions.  
 - Document possible HTTP status codes and error payloads for each route in `docs/errors/`, integrated with OpenAPI.
- Always use get_error_response() from app.config.error_codes instead of exposing detailed validation errors to the frontend. Log detailed errors with logger.warning() or logger.error() for debugging, but return sanitized, user-friendly error messages to clients

[Security & Access Control]
 - Secure endpoints with JWT auth and enforce RBAC via FastAPI dependencies if implementing auth.  
 - Never expose raw exception traces to clients; only generic messages.  
 - Sanitize and validate every input to prevent injections.

[API Documentation]
 - Write clear FastAPI docstrings for each endpoint, parameter, and response model so `/docs` (Swagger UI) is comprehensive.  
 - After each feature, update `README.md` with new endpoints, usage examples, and required env vars.
 
[Audit Trail]
 - Log every chat activityâ€”transfers, notes, participant changesâ€”to an `audit_logs` collection via a dedicated service, including timestamps and user IDs.

[Data Persistence & History If Applicable]
 - Persist chat sessions indefinitely in MongoDB; provide service-layer methods to fetch historical conversations and participant history for any client.

[Testing & CI/CD]
 - Write pytest unit and integration tests for every new feature; mock external dependencies; target â‰¥80% coverage.  
 - Integrate tests into CI so every pull request runs the full suite before merge.

[Containerization & Deployment]
 - Use a multi-stage `Dockerfile` (slim base, non-root user, cached dependencies) and maintain `docker-compose.yml` for local dev.  
 - On each dependency or code change, verify Docker images build and containers start successfully.

[Documentation Maintenance]
 - Whenever a change, new feature, or structural update is made that affects documentation, always update the relevant files: `README.md`, `WEBHOOK_SETUP_GUIDE.md`, and `WHATSAPP_SETUP_GUIDE.md` to ensure they remain accurate and up to date.

[Index Maintenance]
 - Whenever you add, remove, or modify MongoDB models or make structural changes to the database, update the indexes in `app/db/client.py` accordingly. Ensure new fields are indexed as needed for performance, and remove or adjust indexes that are no longer required or could cause conflicts.

[File & Folder Organization]
 - Place new models in the appropriate subfolder under `app/db/models/` based on their feature or domain. If a relevant subfolder does not exist, create a new one.
 - Place new request and response schemas in the correct subfolder under `app/schemas/` according to their feature or endpoint. Create a new subfolder if needed.
 - Place new route files in the appropriate subfolder under `app/api/routes/` by feature. If a suitable subfolder does not exist, create one.

[Route File Size & Specificity]
 - Each route file in `app/api/routes/` should contain only one endpoint. Avoid large files with multiple endpoints; instead, create more specific route files under the correct subfolder to keep files small and focused.


## ðŸš€ **Implementation Checklist**

When creating new backend features, ensure:

- [ ] âœ… Service layer follows single responsibility principle
- [ ] âœ… Proper error handling with standardized responses
- [ ] âœ… Database indexes are optimized for common queries
- [ ] âœ… Input validation with Pydantic schemas
- [ ] âœ… Audit logging for all operations
- [ ] âœ… Proper authentication and authorization
- [ ] âœ… Comprehensive API documentation
- [ ] âœ… Unit and integration tests
- [ ] âœ… Configuration management with environment variables
- [ ] âœ… Proper logging with correlation IDs
- [ ] âœ… Database transactions for complex operations
- [ ] âœ… Rate limiting and security measures
- [ ] âœ… Performance monitoring and metrics
- [ ] âœ… Proper HTTP status codes
- [ ] âœ… Consistent API response formats