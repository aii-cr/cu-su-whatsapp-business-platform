---
alwaysApply: false
---

# Real-Time Messaging System Architecture - AI Context

## 🏗️ **System Overview**

This application implements a sophisticated real-time messaging system with separate WebSocket connections for chat conversations and dashboard updates. The system handles WhatsApp webhook processing, real-time notifications, and intelligent state management.

## 🔄 **Core Architecture**

### **Backend (FastAPI)**
- **WebSocket Routes**: `/ws/chat/{user_id}` and `/ws/dashboard/{user_id}`
- **WebSocket Service**: Global `ConnectionManager` with conversation and dashboard subscriptions
- **Webhook Processing**: Processes WhatsApp messages and triggers WebSocket notifications

### **Frontend (Next.js + React Query)**
- **MessagingWebSocketClient**: Handles conversation-specific messaging
- **DashboardWebSocketClient**: Handles dashboard updates
- **React Query**: Cache and automatic data invalidation

## 📡 **Data Flow**

```
WhatsApp Webhook → Processing → WebSocket Service → Broadcast → Frontend Clients → UI Update
```

### **1. Incoming Message Flow**
```python
# webhook.py
await websocket_service.notify_incoming_message_processed(
    conversation_id=str(conversation["_id"]),
    message=message,
    is_new_conversation=is_new_conversation,
    conversation=conversation
)
```

### **2. WebSocket Service Structure**
```python
# websocket_service.py
class ConnectionManager:
    - active_connections: Dict[str, Set[WebSocket]]
    - conversation_subscribers: Dict[str, Set[str]]
    - dashboard_subscribers: Set[str]
    - unread_counts: Dict[str, Dict[str, int]]
```

### **3. Frontend Client Architecture**
```typescript
// websocket.ts - For specific conversations
class MessagingWebSocketClient extends WebSocketClient {
  - subscribeToConversation(conversationId: string)
  - handleNewMessage(data)
  - updateOptimisticMessage()
}

// dashboardWebsocket.ts - For dashboard
class DashboardWebSocketClient extends WebSocketClient {
  - subscribeToDashboard()
  - handleUnreadCountUpdate()
  - handleStatsUpdate()
}
```

## 📨 **WebSocket Message Types**

### **Conversation Messages**
- `new_message`: New message received
- `message_status`: Status update (sent/delivered/read)
- `messages_read`: Read confirmation
- `conversation_update`: Conversation changes
- `user_activity`: User activity (typing)

### **Dashboard Messages**
- `new_conversation`: New conversation created
- `conversation_list_update`: List updates
- `stats_update`: Statistics updates
- `unread_count_update`: Unread count changes
- `initial_unread_counts`: Initial counts on connection

## 🎯 **Key Features**

### **Intelligent Subscriptions**
- Users subscribe to specific conversations
- Dashboard auto-subscribes on connection
- Automatic reconnection with resubscription

### **State Management**
- Unread counts per user/conversation
- Auto-mark as read if agent is viewing
- Optimistic messages with real data updates

### **React Query Integration**
```typescript
// Automatic invalidation on updates
this.queryClient.invalidateQueries({
  queryKey: messageQueryKeys.conversationMessages(conversation_id)
});
```

## ⚠️ **CRITICAL RULES - DO NOT BREAK**

### **NEVER CHANGE:**
1. **WebSocket Route Structure** - Keep separate endpoints for chat and dashboard
2. **ConnectionManager** - It's a global singleton, don't instantiate new ones
3. **Message Types** - Maintain existing JSON structure
4. **React Query Keys** - Use existing ones for invalidation
5. **Auto-subscription** - Dashboard subscribes automatically

### **FOLLOW THESE PATTERNS:**
1. **Broadcast to conversation**: `manager.broadcast_to_conversation()`
2. **Broadcast to dashboard**: `manager.broadcast_to_dashboard()`
3. **Personal message**: `manager.send_personal_message()`
4. **Invalidation**: Use existing React Query keys
5. **Logging**: Use consistent emojis and prefixes

### **FILE STRUCTURE:**
```
app/api/routes/websocket.py                    # WebSocket endpoints
app/services/websocket/websocket_service.py    # Service and ConnectionManager
frontend/src/lib/websocket.ts                  # Conversation client
frontend/src/lib/dashboardWebsocket.ts         # Dashboard client
frontend/src/hooks/useDashboardWebSocket.ts    # Dashboard hook
```

## 🔧 **Core Functions**

### **Backend Functions**
- `manager.connect()`: Connect WebSocket
- `manager.subscribe_to_conversation()`: Subscribe to conversation
- `manager.subscribe_to_dashboard()`: Subscribe to dashboard
- `websocket_service.notify_*()`: Send notifications

### **Frontend Functions**
- `MessagingWebSocketClient.subscribeToConversation()`: Subscribe from frontend
- `DashboardWebSocketClient.subscribeToDashboard()`: Subscribe dashboard
- `queryClient.invalidateQueries()`: Invalidate React Query cache

## 📊 **State Management**

### **Unread Counts**
- Increment only for assigned agent
- Reset when agent reads messages
- Calculate from database on connection

### **Connection States**
- `WebSocket.OPEN`: Connected
- `WebSocket.CONNECTING`: Connecting
- `WebSocket.CLOSED`: Disconnected
- Automatic reconnection with exponential backoff

## 🚀 **Implementation Guidelines**

### **When Adding New Features:**
- [ ] ✅ Use existing WebSocket patterns
- [ ] ✅ Follow message type structure
- [ ] ✅ Use proper broadcast methods
- [ ] ✅ Update React Query appropriately
- [ ] ✅ Maintain separation between chat and dashboard
- [ ] ✅ Add proper logging with emojis
- [ ] ✅ Handle reconnection scenarios
- [ ] ✅ Test with multiple connections

### **When Modifying Existing Code:**
- [ ] ✅ Don't break ConnectionManager singleton
- [ ] ✅ Maintain message type compatibility
- [ ] ✅ Preserve subscription logic
- [ ] ✅ Keep React Query integration intact
- [ ] ✅ Test WebSocket reconnection
- [ ] ✅ Verify dashboard updates still work

## 🔍 **Debugging Patterns**

### **Common Issues:**
1. **Messages not updating**: Check React Query invalidation
2. **WebSocket disconnections**: Verify reconnection logic
3. **Unread counts wrong**: Check database vs memory state
4. **Dashboard not updating**: Verify dashboard subscription

### **Logging Patterns:**
```typescript
console.log('🔔 [WEBSOCKET] Message received:', data);
console.log('🏠 [DASHBOARD_WS] Stats update:', stats);
console.log('📊 [UNREAD] Count updated:', count);
```

## 📋 **Testing Checklist**

### **WebSocket Testing:**
- [ ] ✅ Connection establishment
- [ ] ✅ Message broadcasting
- [ ] ✅ Subscription management
- [ ] ✅ Reconnection handling
- [ ] ✅ Multiple user scenarios
- [ ] ✅ Dashboard vs chat separation

### **Integration Testing:**
- [ ] ✅ Webhook to WebSocket flow
- [ ] ✅ Frontend state updates
- [ ] ✅ React Query invalidation
- [ ] ✅ Unread count accuracy
- [ ] ✅ Optimistic updates

## 🎯 **Performance Considerations**

### **WebSocket Optimization:**
- Connection pooling per user
- Efficient message serialization
- Subscription cleanup on disconnect
- Memory management for unread counts

### **Frontend Optimization:**
- React Query caching strategies
- Efficient re-rendering patterns
- Optimistic update handling
- Connection state management

This context must be respected to maintain the integrity of the real-time messaging system. Any modifications should follow these established patterns and avoid breaking the existing architecture.
description:
globs:
alwaysApply: false
---
